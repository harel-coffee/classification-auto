'''
A helper functionality for the deprecated physically-based particle count estimator. Despite good
performance on an artificial dataset (generated by first version of the generator, located in
the folder datagen), it performed very poorly with the real data so it was not used in the final
implementation.

It is used only by the deprecated estimator, reconstructor_histogram.py.
'''


from dataProcessing.extractionFcns import area
import numpy as np
from sklearn.neighbors import KernelDensity
from sklearn.decomposition.pca import PCA
import pickle as pkl

class CondDensityEstimator():
    def __init__(self, jointEstimator, priorEstimator):
        self.jointEstimator = jointEstimator
        self.priorEstimator = priorEstimator

    def score_samples(self, S_array, X_array):
        p_S_and_X = self.jointEstimator.score_samples(np.hstack((np.atleast_2d(S_array).transpose(),
                                                                 X_array)))
        p_X = self.priorEstimator.score_samples(X_array)
        return np.exp(p_S_and_X-p_X)

def estimate_P_SgX(areas, binned_images):
    """
    :param areas: numpy array of areas of particular particle class given image binned_ims
    :param binned_ims: binned images in numpy array, must be flattened, each row one image
    :return:
    """
    print(areas)
    est_P_S_and_X = KernelDensity(kernel='gaussian', bandwidth=2)
    est_P_X = KernelDensity(kernel='gaussian', bandwidth=2)
    est_P_S_and_X.fit(np.hstack((np.atleast_2d(areas).transpose(), binned_images)))
    est_P_X.fit(binned_images)
    est_P_SgX = CondDensityEstimator(est_P_S_and_X, est_P_X)
    return est_P_SgX


def find_distributions(query_areas, query_energies, binned_image,
                       n_classes=2,
                       bimages_path='/home/fin/Documents/Timepix/particle-tk/datagen/images.pkl',
                       segments_path='/home/fin/Documents/Timepix/particle-tk/datagen/segments.pkl'):

    # Load binned images and segments
    b_im = pkl.load(open(bimages_path, 'rb'))
    segments = pkl.load(open(segments_path, 'rb'))
    reductor = PCA(n_components=3)
    b_im = reductor.fit_transform(b_im)
    queried_binned_image = reductor.transform(binned_image.reshape(1,-1))

    areas = [[] for i in range(0,n_classes)]
    pixel_energies = [[] for i in range(0,n_classes)]
    binned_images = [[] for i in range(0,n_classes)]
    binned_images_energies = [[] for i in range(0,n_classes)]

    for segment in segments:
        for lbl in range(1,n_classes+1):
            if segment.get_metadata('label') == lbl:
                areas[lbl-1].append(area(segment.get_bitmap()))
                nonzeroE = segment.get_bitmap().flatten()[segment.get_bitmap().flatten() > 0]
                for e in nonzeroE:
                    pixel_energies[lbl-1].append(e)
                    binned_images_energies[lbl-1].append(b_im[segment.get_metadata('parent_im_id')])
                binned_images[lbl-1].append(b_im[segment.get_metadata('parent_im_id')])
                break

    # Estimation of size density given image
    sizes = list() # for each particle type one array of size
    sizes.append(np.linspace(0,20,100))
    sizes.append(np.linspace(0,10,100))
    energies = list()
    energies.append(np.linspace(0,400,100))
    energies.append(np.linspace(0,400,100))
    p_SgX = list()
    p_EgX = list()

    for lbl in range(1,n_classes+1):
        print(areas[lbl-1])
        estimator_P_SgX = estimate_P_SgX(areas[lbl-1], binned_images[lbl-1])
        estimator_P_EgX = estimate_P_SgX(pixel_energies[lbl-1], binned_images_energies[lbl-1])
        p_SgX.append(estimator_P_SgX.score_samples(query_areas[lbl-1,:],
                                                   np.repeat(np.atleast_2d(queried_binned_image),
                                                             query_areas[lbl-1,:].shape[0], axis=0)))
        p_EgX.append(estimator_P_EgX.score_samples(query_energies[lbl-1,:],
                                                   np.repeat(np.atleast_2d(queried_binned_image),
                                                             query_energies[lbl-1,:].shape[0], axis=0)))
    return np.array(p_SgX), np.array(p_EgX)